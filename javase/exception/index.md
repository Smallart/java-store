# 异常

发现错误的理想实际是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能够通过某种方式，把适当的信息传递给某个接收者--该接收者将知道如何正确处理这个问题。

Java中异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成，并且通过这种方式可以使得你更加确信：你的应用中没有未处理的错误。

当问题出现时，当前环境没有足够的信息来解决这个问题，所以就把这个问题提交到一个更加高级的环境中，在那里将做出正确的决定。

异常往往能能降低错误处理代码的复杂度。如果不使用异常，那么就必须检测特定的错误，并在程序中的许多地方去处理它。如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误。理想情况下，只需要在一个地方处理错误，即所谓的异常处理程序中，这种方法不仅节省代码，而且把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。

异常情形（Exceptional condition）是指阻止当前方法或作用域继续执行的问题。把异常情形和普通问题区分很重要，所谓的普通问题是指，在当前环境下能够得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去，应为在当前环境下无法获得必要的信息来解决问题。所以你需要从当前环境跳出，并且把问题提交给上一级环境。

当抛出异常后，同Java中其他对象的创建一样，将使用new在堆上创建异常对象。然后当前执行的路径被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。

异常允许你将做的每件事都当作一个事务来考虑，而异常守护者这些事务。你也可以将异常看作是一种恢复系统，因为你在程序中可以有各种恢复点。一旦程序的一部分失败了，异常将“恢复”到一个已知的稳定点上。

## 异常捕获

要明白异常是如何被捕获的，必须首先理解监控区域（guarded region）的概念。这是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

```java
// 抛出异常
throw new RunTimeException();

try{
    // 监控区域
}catch(Exception1 e){
    // 异常处理区域
}catch(Exception2 e){

}

```
当监控区域抛出异常，则交由catch区域配置抛出的异常，匹配到来就进行处理在接下来进行处理。

## 异常声明
Java鼓励人们把方法可能抛出的异常告知使用此方法的客户端程序员，它使调用者能确切知道写什么样的代码可以捕获所有潜在的异常。

代码必须与异常说明保持一致，如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒：俺么处理这个异常，那么就在异常说明中表明此方法将产生异常。

**栈轨迹：**表示出现问题方法调用的路径，使用`printStackTrace()`查看。

```java
public class WhoCalled{
    static void f(){
        try{
            throw new Excpetion();
        }catch(Exception e){
            for(StatckTraceElement ste:e.getStackTrace()){
                System.out.println(ste.getMethodName());
            }
        }
    }
    static void g(){f();}
    static void h(){g();}
    public static void main(String[] args){
        f();
        System.out.println("***********");
        g();
        System.out.println("***********");
        h();
    }
}
/**
f
main
*******
f
g
main
*******
f
g
h
main
*/
```

**重新抛出异常：**有时希望把刚捕获的异常重新抛出。
```java
catch(Exception e){
    System.out.println("An exception was thrown");
    throw e;
}
```
重抛异常会把异常抛出给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略。此外，异常对象的所有信息都得以保持，所以高一级的环境中捕获此异常的处理程序可以从这个异常对象得到所有信息。

如果只是把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息。而并非重新抛出点的信息。要想更新这个信息，可以调用fillStackTrace方法，这将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立。也就是说抛出点变为了最新的抛出点。

有时候会在捕获异常之后抛出另一种异常，那么做的化，得到的效果类似于使用`fillStackTrace`有关原来异常发生点的信息会丢失，剩下的与新的抛出点有关的信息，永远不必为清理前一个异常对象而担心，它们都是用new在堆上创建的对象，所以垃圾回收器会自动把它们清理掉。

**异常链**：常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这就称之为异常链。所有Throwable的子类在构造器中都可以接受一个cause对象作为参数，这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使当前位置创建并抛出新的异常，也能通过这个异常链追踪到异常最初发生的位置。

而在Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造函数。它们是Error、Exception以及RuntimeException。如果要把其他类型的异常连接起来，应该使用initCause()方法而不是构造器。

## Java标准异常
Throwable这个Java类被用来表示任何可以作为异常抛出类。Throwable对象可以分为两种类型：Error表示编译和系统错误；Exception是在类库或是方法及其运行时故障时抛出的Exception型异常。

基本理念时用异常的名称代表发生的问题。异常的名称应该可以望文知意。

有一些代码片段，可能希望无论try块中的异常是否抛出，它们都能得到执行。为了达到这个效果，可以在异常处理程序后面加上finally子句。
```java
try{}catch(Exception e){

}finally{
    // activities that happen every time
}
```
finally 的用途就是将无法被垃圾回收装置自动回收的，手动解决。一般是文件流的关闭。

一个出现在基类方法的异常说明中的异常，不一定会出现在派生类方法的异常说明里。

抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序，找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续插座。