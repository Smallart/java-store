# 基础

**四大口诀：** `高内聚低耦合，线程操作资源类`、`判断、动作、唤醒`、`拒绝虚假唤醒（wait方法要注意使用while判断）`和`修改标志位（可能是volatile）`。

线程的好处：充分了利用硬件资源，提高程序运行效率。

**进程、线程与管程**：

* 进程：程序的一次运行
* 线程：在同一个进程中又可以执行多个任务，而这每一个任务我们都可以看作时一个线程，线程之间共享进程的资源。
* 管程：就是Monitor（监视器），它的义务是保证同一时间只有一个线程访问被保护的数据和代码

底层原理：Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种不同结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。方法级的同步是隐形的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED方法标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC+SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法在获得同一个管程。如果一个同步方法执行期间抛出异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。

同步一段指令集序列通常由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter、monitorexit两条指令来支持synchronzied关键字的语句，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。

## [-[CompletableFuture]-]

定义线程的三种方式：`继承Thread`、`实现Runaable`、`实现Callable`

第三种方式与其他两种不同在于Callable是为了获得线程的计算结果，最后包装为`FutureTask`，赋值给`Thread`。
`FutureTask`通过父类`RunnableFuture`间接实现了`Runnable`和`Future`接口。其中的`Future`接口定义了对线程状态的操作，比如取消该线程，或是通过`get`方法阻塞调用的子线程，直到子线程计算完全。

`CompletableFuture`提供了强大的Future扩展功能，帮我们简化了异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方法计算结果。也就是说它如果多个线程之间的通信，它使得你简化了对锁和标志位的控制，直接使得你可以专注于相关业务逻辑。

`CompletableFuture`其中一个直接父类`CompletationStage`:
* CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另一个阶段
* 一个阶段的计算执行可以是一个Function，Consumer或者Runnable。

一个阶段的执行可能被单个阶段的完成触发，也可能是有多个阶段一起触发。

`CompletableFuture：`开始的两个静态方法`runAsync(无返回值)`和`ApplySync(有返回值)`

CompletableFuture的优点：
* 异常任务结束，会自动回调某个对象的方法
* 异常任务出错，会自动回调某个对象的方法
* 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行
