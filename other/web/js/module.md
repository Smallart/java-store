# 模块
随着前端的复杂化、规范化，为了能够复用js代码，所以就需要将不同功能的代码抽离并且隔离。这样的好处就是减少了一次性加载脚本的代码量，并且使得不同功能的代码块有了自己的代码域，这样避免了开发命名上可能照成的冲突问题。

之前有了一些js代码模块化的解决方案：AMD、CommonJS、UMD，但是ES6之后官方就添加模块化的语法。

## 语法

模块可以相互加载，并可以使用特殊的指令`export`和`import`来交换功能，从另一个模块调用一个模块的函数：

* export：标记可以从其当前模块外部访问的变量和函数
* import：关键字允许从其他模块导入功能

````js
// 一个模块中，可以有多个export关键字，其中可以导入变量，方法以及类
/**
 *  在类或函数前的export不会让它们变成函数表达式，它只是一个函数声明
 * 
*/
export let months = [];
export class User{}
export function demo(){}

///////////一起导////////////
class User{}
function demo(){}
export {User,demo}

////////////默认导出//////////
// 一个模块只做一件事，则导出也变的不同(不需要花括号),并且每个模块只能有一个默认导出。默认导出之后的变量名可以不一致

export default class User{}
import User from ''
````

````js
// 导入一个模块提供的接口
import {User,demo} from ''

//重命名
import {User as u,demo as d} from ''

// 如果有很多要导入的内容，则可以将所有内容导入为一个对象中，这就有个问题就是会将所有的东西都导出，可能有些是我们不需要的，这就导致之后打包的文件特别大
import * as ob from ''

````

注意的是：模块只通过HTTP工作，在本地文件则不行。

模块的特点：

* 模块默认使用`use strict`
* 每个模块都有自己的顶级作用域。也就是说，一个模块中的顶级作用域变量和函数在其他的脚本中是不可见的（除了主动引入）
* 如果一个模块被导入到多个其他位置，那么它其中的代码只会在第一个导入时执行（有点像java中的静态代码块）、
* 在一个模块中，“this”是undefined

浏览器下模块的特点：
* 模块脚本总是被延迟的，也就是下载脚本是异步的，模块脚本会得到html文档完全准备就绪，然后才被运行。并且在文档中排在前面的脚本先执行。

## 动态导入

````js
//动态导入，以下表达式加载模块并且返回一个promise。
import() 

````

## 复合语句

```js
// 二次导出，一般用于对其他包的二次封装
export {} from ''
```