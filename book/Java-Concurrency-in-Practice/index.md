# 简介

引入多线程的原因：资源利用率、公平性以及便利性。

 * **资源利用率：**当某个程序在等待的[-[IO]-]的结果，此时将它手中的[-[CPU]-]资源分配给另一个程序，则可以提高硬件的使用效率。
 * **公平性：**每个程序都可以通过时间分片的方式执行，而不需要等待一个程序从头执行到尾。
 * **便利性：**在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要时相互通信。

 每个程序可以看作是一个进程，并且以上因素同样也促进了线程的出现。线程允许在同一个进程中同时存在多个程序控制流。线程会共享进程范围内的资源。线程也被称之为轻量级进程。在大多数现代操作系统中，都是以线程位基本的调用单位，而不是进程。如果没有明确的协同机制，那么线程将彼此独立执行。由于同一个进程中的所有线程都将共享进程的内存地址空间，所以这些线程都能够访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确通过机制来协同堆共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这就会造成不可预测的结果。

 线程的优势，线程可以有效地降低程序的开发和维护等成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换为串行工作流，能更好模拟人类的工作方式和交互方式，此时，线程还可以降低代码的复杂性，使得代码更加容易编写、阅读和维护。多个线程还有助于在单处理器系统上获得更高的吞吐率。如果程序是单线程的，那么当程序等待某个同步[-[IO]-]操作完成时，处理器将处于空闲状态。而在多线程程序中，如果一个线程在等待[-[IO]-]操作完成，另一个线程可以继续允许，使程序能够在[-[IO]-]阻塞期间继续运行。

由于多个线程要共享相同的内存地址空间，并且使并发运行，因此它们可能会访问或修改其他线程正在使用的变量。当然这是方式比其他线程间通信机制更容易实现线程共享。但是同样他也有极大的风险：线程往往会因为无法预料数据变化而发生错误。当多个线程同时访问和修改相同的变量时，将会在串行编程模型中引入非串行因素，而这种非串行性是很难分析的。

在设计良好的并发程序中，线程能提升程序的性能，但是无论如何，线程总会带来某种程序的运行开销。在多线程程序中，当线程调度临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将回带来极大的开销：保存和恢复执行上下文，丢失局部性，并且[-[CPU]-]时间将更多花费在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使得内存缓存区中的数据无效，以及增加共享内存总线的同步流量。所有这些因素都将会带来额外的性能开销。

## 线程安全性

在构建稳健的并发程序时，必须正确地使用线程和锁。但这些终归只是一些机制，要编写线程安全的代码，其核心在于对状态访问操作进行管理，特别是对共享的和可变的状态的访问。

从非正式的意义上来说，对象的状态是指存储在状态变量（实例或静态域）中的数据。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以访问变化。我们将讨论代码那样来讨论线程安全性，但更侧重于如何防止在数据上发生不受控的并发访问。一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。

当多个线程访问某个状态变量并且其中一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。[-[Java]-]中的主要同步机制的关键词[-[Synchronized]-]，它提供了一种独特的加锁方式，但“同步”这个术语还包括了[-[volatile]-]类型的变量，显示锁[-[Explicit Lock]-]以及原子变量。

如果多个线程访问同一个可变的状态变量时，没有使用合适的同步，那么程序就会出现错误。由三种方式可以修复这个问题：
* 不在线程之间共享该状态变量
* 将状态变量修改位不可变的变量
* 在访问状态变量时使用同步

> 线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。

**无状态对象一定是线程安全的。**：当一个类不包含任何域，也不包含任何对其他类中域的引用，就称之为无状态类。

###　原子性
在并发编程中，这种由于不恰当的执行时序而出现不正确的结果产生的一种情况，它被称之为静态条件。当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生静态条件。就是正确的结果要取决于运气。最常见的竞态条件类型就是“先检查后执行”操作，及通过一个可能失效的国策结果来决定下一步的动作。

使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的就是将都对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

```java
public class lazyinitRate{
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance(){
        if(instance == null){
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```
与大部分并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。并且，竞态条件可能会导致严重的问题。像上面的单例模式可能会由于并发问题在程序运行中产生多个对象。

### 复合操作

要修改上面单例模式的多线程问题，就需要包含一组需要以原子方式执行（或者说不可分隔）的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个便令，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。

假定有个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，那么完全不执行B，那么A和B对彼此来说是原子操作的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作时一个以原子方式执行的操作。我们通过加锁机制来确保原子性。

当一个无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。

在实际情况中，应尽可能地使用现有的线程安全对象来管理类状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其转换情况要更加容易，从而也更容易维护和验证线程安全性。

当类中有多个状态值，每个状态值都使用了原子引用，那么是否可以保证线程的安全性。

```java
public class UnsafeCacheingFactorizer implements Servlet{
    private final AtomicaRefreence<BigInteger> lastNumber = new AtomicReference<BigInteger>();
    private final AtomicRefrerence<BigInteger[]> lastFacotrs = new AtomicReference<BigInteger[]>()

    public void service(ServletRequest req,ServletReponse resp){
        BigINteger i = extractFromRequest(req);
        if(i.equals(lastNumber.get())){
            encodeIntoResponse(resp,lastFactors.get());
        }else{
            BigInteger[] factorst = facotry(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp,factors);
        }
    }
}
```

虽然这些原子性本身是线程安全的，但是还是存在竞态条件，这可能产生错误。在线程安全性的定义要求中，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。[-[UnsafeCachingFactorizer]-]的不变性条件之一：在[-[lastFactory]-]中缓存的因数之积应该等于在[-[lastNumber]-]中缓存的数值。只有确保这个不变性条件不被破坏，上面的[-[Servlet]-]才是正确的，当不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某个变量时，需要在同一个原子操作中对其他变量同时进行更新。

> 要保持状态的一致性，就需要在单个原子操作更新所有相关的状态变量

### 内置锁
[-[Java]-]提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包含两个部分：一个作为锁的对象应用，一个作为由这个锁保护的代码块。以关键字synchronzied来修饰的方法就是一种横跨整个方法体的同步代码块，其中该通过代码块的锁就是方法调用所在的对象。静态的synchronzied方法以Class对象位锁。

```java
synchronized(lock){

}
```
每个对象都可以用做一个实现同步的锁，这些锁称为内置锁（Intrinsic Lock）或监视锁（Monitor Lock）。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java的内置锁相当于一种互斥体（或互斥锁），这就意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或是阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也就将永远等待下去。

由于每次只能有一个线程执行内置锁保护的代码块，所以这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会相互干扰。并发环境中的原子性与事务应用程序中的原子性有相同的含义--一组语句作为一个不同分隔的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。

synchronzied实现的内置锁虽然简单，但是效率低下。

**重入**：当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然后由于内置锁时可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。

“重入”意味着获取锁的请求操作的粒度是“线程”，而不是调用。

## 用锁来保护状态

由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能确保状态的一致性。

访问共享状态的复合操作，例如命中计数器的递增操作（读写-修改-写入）或者延迟初始化（先检查后执行），都必须是原子操作以避免产生竞态条件。如果在复合操作的执行过程中持有一个锁，如果会使复合操作成为原子操作。然而仅仅将复合操作封装到一个同步代码块中是不够的。如果同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

对象的内置锁与其状态之间没有内在的关联。虽然大多数类都将内置锁用做同一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。当获取域对象关联的锁时，并不能阻止其它线程访问该对象，某个线程在获得对象的锁之后，只能阻止其它线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显示地创建锁对象。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

当某个变量由锁来保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量。当类的不变性条件涉及多个状态变量时，那么还有另一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。

> 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要有一个锁来保护。

判断同步代码块的合理大小，需要在各个设计需求之间进行权衡，包括安全性、简单性和性能。通过在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为性能而牺牲简单性。（这就可能会破坏安全性）

当使用锁时，你应该清楚代码块中实现的功能，以及在执行代码块时是否需要很长的时间。无论时执行计算密集的操作，还是执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。

> 当执行时间较长的计算或则无法快速完成的操作时（网络或是IO）一定不要持有锁。

## 对象的共享

之前曾指出，要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要进行正确的管理。前面介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据，接下来就介绍如何共享和发布对象，从而使得它们能够安全地由多个线程同时访问。

同步代码块和同步方法可以确保以原子的方式执行擦欧总，但一种常见的误解是，认为关键字synchronzied只能用于实现原子性或者确定“临界区”。同步还有另一个重要的方面：内存可见行。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。

### 可见性

在单线程环境中，如果像某个变量写入值，然后再没有其他写入操作的情况下读取这个变量，那么总能得到相同的值。这再单线程的情况下看起来很自然，然而，当读操作和写操作再不同的线程中执行时，情况却并非如此。通常我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见行，必须使用同步机制。

```java
public class NoVisibility{
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread{
        public void run(){
            while(!ready)
            Thread.yield();
            System.out.println(number)
        }
    }
    public static void main(String[] args){
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```
以上程序可能会持续循环下去，因为读线程可能永远都看不到ready的值。一种更奇怪的现象是，该程序的输出可能为0，因为读线程可能看到写入ready的值，但是却没有看到之后写入number的值，这种线程称之为“重排序”。只要在某个线程中无法检测到重排情况，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主程序首先写入number，然后在没有同步的情况下下入ready，那么读线程看到的顺序可能与写入的顺序完全相反。

> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要相对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

为了避免这种情况：只要有数据在多个数据之间共享，就是用正确的同步。

### 失效数据
当读线程查看ready变量，可能会得到一个已经失效的值。除非每次访问便令都是用不同，否则可能获得该变量的一个失效值。并且失效值可能不会同时出现，一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。

### 非原子的64位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全保证也被称为最低安全性。
最低安全性适合于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量。Java内存模型要求，变量的读取操作和写入操作必须是原子操作，但是对于非volatile类型的long和double变量，JVM允许将64位读操作和写操作分解为两个32位的操作。但读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能读取到某个值的高32位和另一个值的低32位。所以，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。

### 加锁和可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果，当线程A执行某个同步代码块时，线程B随后进入由同一锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁之后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现上述保证：

![加锁可见行](/img/visible.png)

这也就是为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值就对于其他线程来说都是可见的。否则如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或是写操作的线程必须在同一个锁上同步。

### Volatile变量
Java语言提供一个稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，就不会将该变量上的操作进行重排。volatile变量不会被缓存在寄存器或则对其他处理器不可见的地方，所以在读取volatile类型的变量总会返回最新写入的值。

加锁机制既可以确保可见行又可以确保原子性，而volatile变量只能确保可见性。
当且仅当满足以下所有条件，才应该使用Volatile变量：
* 对变量的写入操作不依赖变量的当前值，或则你确保只有单个线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 在访问变量时不需要加锁

