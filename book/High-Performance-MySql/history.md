# MySQL

![MySql架构](/img/frame.png)

最上层不是MySQL独有的，大多数基于网络的客户端/服务器的工具或是服务都有类似的架构。比如：连接处理、授权认证与安全等等。

第二层是MySQL核心服务功能：查询解析、分析、优化、缓存以及所有的内置函数。所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。

MySQL在查询时，会解析查询语句，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定标的读取顺序，以及选择合适的引擎等。用户可以铜鼓特殊的关键字提示优化器，影响他的决策过程。优化器并不关心表使用的是什么存储引擎，但是存储引擎对应优化查询是有影响的，优化器会请求存储引擎的某种索引，可能对一些特定的查询有优化。

对于SELECT语句，在解析查询之前，服务器会检查查询缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存的结果集。

## 锁粒度
**表锁**：锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。

**行级锁**：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。其中InnoDB和XtraDB，以及其他一些存储引擎中实现行级锁。行级锁只在存储引擎曾实现，而MySQL服务层没有实现。服务层完全不了解存储引擎中的锁实现。

## 事务
事务就是一组原子性的SQL查询，或者说一个独立的工作单元，如果数据引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中任何一条语句因为崩溃或则其他原因无法执行，那么所有语句都不会执行。也就是事务内的语句，那么全部执行成功，要么全部执行失败。

除非系统通过严格的ACID测试，ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。
**原子性：**一个事务必须被视为一个不可分隔的最小工作单元，整个事务中收纳柜的所有操作要么全部提交成功，那么全部失败回滚，对于一个事务来说，不可能执行其中的一部分，这就是事务的原子性。

**一致性：**数据库总是从一个一致性的状态转换到另一个一致性的状态。

**隔离级别：**通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。

**持久性：**一旦事务提交，则其所做的修改就会永久保留到数据库中。

### 隔离级别

隔离性其实比想象的更复杂，在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销更低。

**READ UNCOMMITTED（未提交读）：**这种级别下，事务的修改，即使没有提交。对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读

**READ COMMITTED（提交读）**大多数数据库系统的默认隔离级别都是READ COMMITTED（但是MySQL不是）。一个事务开始时，只能“看到”已经提提交的事务所做的修改。也就是说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候叫做不可重复读，因为两次执行相同的查询，可能会得到不一样的结果。

**REPEATABLE READ(可重复读)**该隔离级别解决了脏读的问题。该级别保证了在同一事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。

**SERIALIZABLE（可串行化）：**SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZEABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

**死锁：**指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

**事务日志：**使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序IO，而不像随机IO需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。

### mySQL中的事务
MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

**自动提交（AUTOCOMMIT）**：MySQL默认采用自动提交模式。也就是说，如果不是显示地开始一个事务，则每个查询都被当作一个事务执行提交操作。可以通过修改AUTOCOMMIT改变这种行为，但是对于非事务型的表，比如MyISAM或则内存表，不会有任何影响。对这类表来说，没有COMMIT或则ROLLBACK的概念，也可以说是相当于一直处于AUTOCOMMIT启动的模式。

### 多版本并发控制（MVCC）
MySQ的大多数事务型存储引擎实现的都不是简单的行级锁，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现，是通过保持数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据是不一样的。

InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间。当然存储的并不是实际时间值，而是系统版本号。每开始一个新的事物，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。

SELECT操作：
* InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存的，那么是事务自身插入或者修改过的。
* 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
只有符合上述两个条件的记录，才能返回作为查询结果。

INSERT操作：
* InnoDB为新插入的每一个保存当前系统版本号作为行版本号。

DELETE操作：
* InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

UPDAET操作：
* InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE则会对所有读取的行都加锁。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在Windows中，大小写时不敏感的，而在UNIX系统中则是敏感的。不同的存储引擎保存数据和索的方式是不同的，但是表的定义则是在MySQL服务层统一处理的。

### InnoDB存储引擎
InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。

InnoDB的数据存储在表空间（tablespace）中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。在MySQL 4.1以后的版本中，InnoDB可以将每个表的数据和所以存放在单独的文件中。InnoDB也可以使用裸设备作为表空间的存储介质。

InnoDB采用MVCC来支持高并发，并且实现四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙表策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB表是基于聚簇锁引建立的，InnoDB的索引结构和MySQL的其他索引由很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引中必须包含主键列，所以如果主键列很大的画，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。InnoDB的存储格式是平台独立的，也就是说可以将数据和索引文件在各个平台上进行复制。

### MyISAM存储引擎

在MySQL 5.1及以前，MyISAM是默认的存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数等，但是MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。但是它对于只读的数据或是表比较小、可以忍受修复操作，则依旧继续使用MyISAM

MyISAM特性：
* 加锁：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。
* 索引特性：即使是BLOB和TEXT等长度，也可以基于前500个字符创建索引。MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复制的查询。

### 转换表的引擎
有很多方法可以将表的存储引擎转换成为另一种引擎。每种方法都有其优点和缺点。
`ALTER TABLE`: `ALTER TABLE mytable ENGINE = InnoDB`. 这个方法适用于任何一个存储引擎，但是有一个问题：需要执行很长时间。MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统的所有I/O能力，同时原表上会加上读锁。并且如果转换表的存储引擎，将会失去和原引擎相关的所以特性。

导入导出：使用mysqldump工具将数据导出到文件，然后修改文件中的CREATE TABLE语句的存储引擎选项，注意修改表名。

创建与查询：
```mysql
CREATE TABLE Innodb_table like myisam_table;
ALTER TABLE innodb_table ENGINE = InnoDB;
INSERT INTO innodb_table SELECT * FROM myisam_table;
```
数量不大时，这样做工作很好。但是数据量很大时，则可以考虑做分批处理，针对每一段数据执行事务提交操作，以避免大事务产生过多的undo。
```mysql
start transaction;
insert into innodb_table select * from myisam_table where id between x and y;
commit;
```

